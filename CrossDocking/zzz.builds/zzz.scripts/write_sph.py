#!/usr/bin/env python
try:
  import os,sys
  import math
  import scipy
  import numpy as np
  from scipy.spatial import distance
except ImportError:
  raise ImportError("Unable to load the necessary modules")
  sys.exit()


## PDB Format####
#1-6  = spaces for ATOM, HETATM, ANISOU
#13-16 = ATOM NAME
#17    = Save for special character
#18-20 = Residue Name
#22    = Chain identifier
#23-26 = Residue Sequence Number
#31-38 = X coordinates in Angstroms Real(8.3)
#39-46 = Y coordinates in Angstroms Real(8.3)
#47-54 = Z coordinates in Angstroms Real(8.3)
#####
#Note: Rember python starts at 0 so subtract one from the starting
#      ending numbers (e.g. 1-6 for spaces, 0-5 for spaces in python
#Template PDB
#ATOM      1  C10 LIG X   1      29.590  13.780   1.030  0.00  0.00
#ATOM      2  C11 LIG X   1      29.060  14.710   2.130  0.00  0.00
#------------------------------------------------------------------

##sph Format###
#cluster     1   number of spheres in cluster    60
#    1  36.69300  45.67000  61.94600   0.700    1
#    2  38.77200  46.39300  68.39900   0.700    2
#    3  37.63500  43.22700  63.08300   0.700    3
#    4  35.21100  41.54400  66.03900   0.700    4
#    5  38.60900  42.96500  67.51500   0.700    5



#Parse through the mol2 file and check to see if it at least has the
#header "<TRIPOS>MOLECULE" which is required by all mol2
def mol2guesser(mol2file):
  TRIPOS=False
  tempfile=open(mol2file,"r")
  for line in tempfile:
    if "<TRIPOS>MOLECULE" in line:
      TRIPOS=True
      break
  tempfile.close()
  if TRIPOS:
    print "reading a MOl2file"
    return True
  else:
    print "reading a PDBfile"
    return False

#Parse through the mol2 file and return the X,Y,Z coordinates
#Note the the atom names is not important
# Add in the near future the ability to only return HEAVY ATOMS
def ReadMol2(mol2file):
  Coords=[]
  tempfile=open(mol2file,"r")
  for line in tempfile:
    if "<TRIPOS>ATOM" in line:
      for line in tempfile:
        if "<TRIPOS>BOND" in line: 
          break
        elif "H" not in line: #no hydrogens TEST NEEDS VALIDATION
          Coords.extend([float(line.split()[2]),float(line.split()[3]),float(line.split()[4])])
  tempfile.close()

  CheckCoordSize(Coords)

  num_columns=len(Coords)/3
  return np.reshape(Coords, (num_columns,3))


#Make sure the Coords are the correct size
def CheckCoordSize(XYZ):
  #Note this might not be necessary because it should break while parsing
  if len(XYZ)==0 or len(XYZ)<3 or len(XYZ) % 3 !=0:
  
     print "The size of the  X,Y,Z coordinates arrays are not same, something went wrong"
     sys.exit()



# Function that reads in pdb xyz coordinates 
# extends makes all the coordinates a 1D or flattend array
#using numpy.reshape creates an array of just xyz coordinates of each atom inside
# of an larger array i.e [1,2,3,4,5,6] --> [[1 2 3][4 5 6]]
def ReadPdb(pdbfile):
  tempfile=open(pdbfile,"r")
  Coords=[]
  for line in tempfile:
    if line[0:4]=="ATOM" or line[0:6]=="HETATM":
      if "H" not in line[12:13]:
        Coords.extend([float(line[30:38]),float(line[39:46]),float(line[47:54])])
  tempfile.close()

  CheckCoordSize(Coords)

  num_columns=len(Coords)/3
  return np.reshape(Coords, (num_columns,3))


#Reads in Sphgen files generated by sphgen.f and returns its coordinates
#Do not read in "cluster    0 number ..." this is consistent with sphere_selector.cpp
# and the Rizzo VS protocol script keep_spheres_close.pl
def ReadSphDock35(sphfile):
  Coords=[]
  sphfileTemp=open(sphfile, "r")
  for line in sphfileTemp:
    if "cluster     0   number of spheres in cluster" in line:
      break
    elif "cluster  " in line or "DOCK 3.5" in line:
      continue
    else:
      Coords.extend([float(line.split()[1]),float(line.split()[2]),float(line.split()[3])])
  sphfileTemp.close()
  CheckCoordSize(Coords)
  num_columns=len(Coords)/3

  return np.reshape(Coords, (num_columns,3))


#Reads in spherefile and determines if it is a generic spherefile or one that has been
#generated by sphgen.f and returns its coordinates
def ReadSph(sphfile):
  tempfile=open(sphfile,"r")
  sphheader=tempfile.readline()
  tempfile.close()
  if "DOCK 3.5 receptor_spheres" in sphheader:   
     
    Coords=ReadSphDock35(sphfile)
  else:
    Coords=np.loadtxt(sphfile, skiprows=1, usecols=(1,2,3))

  return Coords


#This function determines if the sphgen generated spheres
#meet the cutoff parameters and returns those that do

def PruneSpheresCalc(RefCoords,SphCoords):
  mincutoff=1.5
  maxcutoff=7
  SpheresKeep=[]

  for xyz in (SphCoords):
    DIST=distanceScipy(RefCoords,xyz)
    #DIST=distance(RefCoords,xyz)
    if DIST <= maxcutoff and DIST >=  mincutoff:
      SpheresKeep=np.append(SpheresKeep,xyz)

  return np.reshape(SpheresKeep,(len(SpheresKeep)/3,3))


#Loops through all the coordinates of Reference
#and calls the function PruneSpheres to determine
#if the Spheres are too close or too far from the Reference Coords
# In addition it checks to see if spheres that meet the criteria
#and have been added in previous cycle or not added again

def PruneSpheres(RefCoords,SphCoords):
  
  SpheresKept=[]
  for atomXYZ in range(len(RefCoords)):
    #if len(SphCoords)==0:
     # break 
    FlaggedSpheres=PruneSpheresCalc(RefCoords[atomXYZ],SphCoords)
    
    if len(FlaggedSpheres) !=0:
      for sphXYZ in FlaggedSpheres:
         sphere_exist=(sphXYZ == SpheresKept)
         if not np.any(sphere_exist):
           SpheresKept.append(sphXYZ)
      FlaggedSpheres=[] # empty the array-holder
    else:
      continue
  return SpheresKept


#This function generates the .sph file
#and it generates the PDB simultaneously
#This is main driver of program
def WriteSph(inputfile,sphfile,outputfile):
  if inputfile.endswith("mol2"):
    RefCoords=ReadMol2(inputfile)
  elif inputfile.endswith("pdb"):
    RefCoords=ReadPdb(inputfile)
  else:
    print "Unrecognized format,the the reference must be either a PDB or MOL2 and have" + \
          " the suffix of pdb or mol2"
    sys.exit()

  if sphfile.endswith("sph"):
    SphCoords=ReadSph(sphfile)
  elif sphfile.endswith("pdb"):
    SphCoords=ReadPdb(sphfile)
  else:
    print "Unrecognized format,the sphere file must be either a SPH or PDB and have" + \
          " the suffix of sph or pdb"
    print sphfile
    sys.exit()
   

  NewSphCoords=PruneSpheres(RefCoords,SphCoords)
  
  if len(NewSphCoords) == 0:
    print "Warning: All of the spheres from sphgen have been prunned\n" + \
          "Adjust the max and min cutoff to retain more spheres"

  OutputSpheres=np.concatenate([NewSphCoords,RefCoords], axis=0)
  #OutputSpheres=NewSphCoords //DEBUG

  sph_tempfile=open(outputfile, "w")
  sph_tempfile.write("cluster %5i   number of spheres in cluster %5i\n"% (1, len(OutputSpheres)))

  pdb_tempfile=open(outputfile+".pdb", "w")
  
  spherenum=1
  radius=0.700 # Hardcoded to match what sphgen.f writes
  del NewSphCoords
  del RefCoords
  x=0
  y=1
  z=2
  for coords in OutputSpheres:
    sph_tempfile.write("%5i%10.5f%10.5f%10.5f%8.3f%5i\n" % (spherenum,coords[x],coords[y],coords[z],float(radius),spherenum))
    pdb_tempfile.write("ATOM  %5d %-4s %3s %1s%4d    %8.3f%8.3f%8.3f %5.2f\n" \
          % (spherenum, " C", "SPH","X",spherenum, coords[x], coords[y], coords[z], 1.00))
    pdb_tempfile.write("TER\n")
    spherenum+=1
  sph_tempfile.close()
  pdb_tempfile.close()

#This function calculates the Euclidean Distance
#This is an option for those who do not have scipy
def distance(Coord1,Coord2):
  dist= math.sqrt((Coord1[0] - Coord2[0])**2 +
                (Coord1[1] - Coord2[1])**2 +
                (Coord1[2] - Coord2[2])**2 )
  return dist

#This function calculates the Euclidean Distance
#This is functions uses scipy and is faster
def distanceScipy(Coord1,Coord2):
  return scipy.spatial.distance.euclidean(Coord1,Coord2)


#Checks that the correct number of args are given
def usage():
  if len(sys.argv)==1 or sys.argv[1]== '-h' or sys.argv[1]== '--help' or len(sys.argv) < 4:
    print "write_sph.py [INPUT file (mol2/pdb)] [INPUT file (sph/pdb)] [OUTPUT (sph)]"
    sys.exit()
 

def main():
  usage()
  if not os.path.isfile(sys.argv[1]):
    print "The file '%s' does not exist" % sys.argv[1]
    quit()
  elif not os.path.isfile(sys.argv[2]):
    print "The file '%s' does not exist" % sys.argv[2]
    quit()
  else:
    WriteSph(sys.argv[1],sys.argv[2],sys.argv[3])

main()



